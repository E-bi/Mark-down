## 项目工作回忆

立项: 经过部门开会讨论, 决定做一个针对内部员工技术文档手机平台, 主要是解决研发团队内部工作交接流程中,文档丢失问题. 特此立项[docP]

技术选型: 

* 整体架构: 前后端分离

* 前端部分: nginx  + html + js + css (轻度写法, 时间比较着急)

* 后端部分: nginx + uwsgi + django + mysql

* 前后端分离原因: 前期是web端的, 方便我们产品端进行安卓或者ios端的扩展, 直接一步到位, 完全采用前后端分离; 前端主要负责所有页面渲染; 后端只负责数据层面的返回[json];

* 我在项目中的定位: 后端的全部功能 (技术总监分配, 熬夜写啊)

* 技术总监(13488873118 郭小闹)

* 遇到问题: 

  1. http无状态?  解决jwt-token

     1. base64 - 展开分析

     2. hmac - 看了jwt源码, 发现用了大量hmac, 有点兴趣就去看了hash的方方面面, 因为python字典也是用了同样的hash算法, 所以还是比较有兴趣的, 看了hash的 1.定长输出 2.不可逆 3.雪崩  哈希一般也是用于密码这部分 . 其他方面可能也用于 大文件的校验完整性, 取部分字节hash校验

        考虑到安全程度不高, 所以没考虑ras256非对称加密, 下次版本再加

     3. token设计思维:

        1. header 明确了算法和token种类
        2. payload 公有声明 & 私有声明
           1. 会议上讨论了一些公有声明: exp过期时间-时间戳(time.time())
           2. 私有声明 : username,uid...
        3. sign: HS256(key, header_bs64 + b'.' + payload_bs64)
        4. token = header_bs64 + b'.' + payload_bs64 + b'.' + sign_bs64

     经过这些细节的挖掘和学习, 我独立实现了一套自己的token; jwt-header 考虑删除,减小包大小, 还有一些过期时间, 校验失败的异常类, 让前端拿到更友好

     (体现非拿来主义)



​	2. csrf - 由于cookies不使用, 取而代之需要前端用大量代码操作token 从而达到权限方面的认证, 攻击者无法模拟我方前端代码, 故攻击难度加大





上午问题还原:

问题: User模块 - 如何做同一时间只有一个用户登录

1. 加个字段 - loginStatus[0/1] 1-已登录 0-未登录
2. 用户A在浏览器a登陆了 loginStatus 0>1
3. 用户Azai浏览器b登录了 loginStatus 1>0

1. login_time Datetime
2. 用户A登录 t1 -> login_time  t1 -> token
3. 用户B二次登录 t2 -> login_time t2 -> token

用户表添加 login_time DatetimeField

用户执行登录时:

1. 用户表更新登录时间 为当前时间
2. 生成token时, 在token中添加login_time[1,2步骤时间相等]
3. 校验token-检查token中的login_time 和 用户表中login_time是否相等; 如果不等, 则证明当前token生成后, 又签发了新的token(有人登陆过); 此时, 返回异常状态码, 告知用户'请重新登录' 

遇到问题

还原: 开发' 同一时间只有一个用户可登录 ' 功能时, 发现同一浏览器中多个标签在多次登录后, 旧标签页里面的需要校验权限的功能均无法使用; 臣等惶恐, 最终发现前端页面在发送token时, 使用的是js变量中的token; 此token在用户进入页面时就已经进行了取值, 导致该token有一定的滞后性, 最终我们建议前端, 在发送token前, 再次获取一下当前的本地存储中的token, 以保证token是最新的



RESTful 接口校验问题:

  1. 修改个人信息

  2. 发表博客

  3. 发表留言

     请求进入视图前, 校验相关权限

     装饰器 - 参数 - 多了一层[3层]

     中间件 - 检验 - 全局 - 请求过滤





了解过, 但没有机会实践, 说一下自己了解的东西